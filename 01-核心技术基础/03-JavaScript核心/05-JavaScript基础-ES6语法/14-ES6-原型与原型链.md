# 原型与原型链 — 入手即用

目标：理解“对象属性查找的路径”和“基于原型的复用”，能定位 this/实例/构造函数/原型之间的关系与常见 API 的用途。

---

## 1. 三个名词一次搞清

- 构造函数（Constructor）：如 `function Person(){}` 或 `class Person {}`
- 原型对象（prototype）：`Person.prototype`，放“实例共享的方法/属性”
- 实例的内部原型（[[Prototype]]）：浏览器中可通过 `obj.__proto__` 访问（规范 API 为 `Object.getPrototypeOf(obj)`）

关系：

```txt
实例 --> [[Prototype]] ----> 构造函数.prototype
                  构造函数.prototype.constructor === 构造函数
```

---

## 2. 原型链上的属性查找

当访问 `obj.foo`：

1. 先看 `obj` 自身是否有 `foo`；
2. 若无，沿 `Object.getPrototypeOf(obj)` 一层层向上查找；
3. 直到 `null`（顶层是 `Object.prototype` 的原型）为止。

判断“自有属性/原型属性”：

```ts
obj.hasOwnProperty("foo"); // 仅判断自身是否拥有
"foo" in obj; // 自身或原型链任意一层拥有都返回 true
```

---

## 3. 用 new 创建实例时发生了什么（简化版）

`new Person()` 等价于：

```ts
const obj = {}; // 1. 创建空对象
Object.setPrototypeOf(obj, Person.prototype); // 2. 关联原型
const ret = Person.call(obj); // 3. 以 obj 作为 this 执行构造函数
return typeof ret === "object" ? ret : obj; // 4. 返回对象
```

---

## 4. class 只是语法糖

```ts
class Person {
  constructor(name) {
    this.name = name;
  }
  say() {
    return `hi, ${this.name}`;
  } // 实际挂在 Person.prototype 上
}

const p = new Person("Ada");
p.say(); // "hi, Ada"
```

等价的原型写法：

```ts
function Person(name) {
  this.name = name;
}
Person.prototype.say = function () {
  return `hi, ${this.name}`;
};
```

---

## 5. 原型相关常用 API

```ts
Object.getPrototypeOf(obj);        // 读取 [[Prototype]]
Object.setPrototypeOf(obj, proto); // 设置 [[Prototype]]（不推荐频繁使用，会降性能）
Object.create(proto, props?);      // 以 proto 为原型创建对象（推荐）
obj.hasOwnProperty(key);           // 是否为自有属性
key in obj;                        // 自身或原型链是否存在
obj instanceof Ctor;               // obj 的原型链上是否能找到 Ctor.prototype
```

`instanceof` 的本质：顺着 `obj` 的原型链找，能否碰到 `Ctor.prototype`。

---

## 6. 小实战：继承与方法复用（不使用 class）

```ts
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function () {
  return `${this.name} makes a noise`;
};

function Dog(name) {
  Animal.call(this, name); // 借用构造函数初始化 this
}

// 原型继承：Dog 的实例原型链指向 Animal.prototype
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // 记得修正 constructor 指针

Dog.prototype.speak = function () {
  return `${this.name} barks`;
};

const d = new Dog("Coco");
d.speak(); // "Coco barks"
"d" in { d }; // false（示例：与 in 无关）
d instanceof Dog; // true
d instanceof Animal; // true
```

---

## 7. 常见坑与建议

- 修改 `SomeCtor.prototype = { ... }` 会覆盖掉默认的 `constructor`，记得手动指回：
  ```ts
  SomeCtor.prototype = {
    /* methods */
  };
  Object.defineProperty(SomeCtor.prototype, "constructor", {
    value: SomeCtor,
    writable: true,
    configurable: true,
  });
  ```
- 不要随意改内置对象的原型（如 `Array.prototype`），会影响全局、难以维护。
- 读写 `__proto__` 仅用于调试，代码里尽量使用 `Object.getPrototypeOf/SetPrototypeOf/Create`。

---

## 8. 速查：如何判断属性在哪里？

```ts
function where(obj: any, key: PropertyKey) {
  let cur = obj;
  while (cur) {
    if (Object.prototype.hasOwnProperty.call(cur, key)) return cur;
    cur = Object.getPrototypeOf(cur);
  }
  return null;
}
```

拿到返回对象即可判断该属性在“自身”或“哪一层原型”上，便于排查覆盖/查找问题。
